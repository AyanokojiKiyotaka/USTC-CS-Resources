/*
 * HashTable: for HashTable
 */

#pragma once

/*
 * HashTable:
 * 定址方法:
 *  1. 直接定址: H(key)=a*key+b
 *  2. 数字分析: 取中间两位之类的. 观察数据来找区分办法.
 *  3. 平方取中: 关键字平方后取中间几位. 常用.
 *  4. 折叠法: 关键字分割成位数相同的部分,取这几部分和. 9每一位数字分布大致均匀可用.
 *  5. 除留余数: H(key)=key % p, p <= m. 最简单常用.
 *  6. 随机数法: 借助随机函数. 关键字不等长时采用.
 * 处理冲突方法:
 *  1. 开放定址法: H_i=(H(key)+d_i) % m, i=1,2,...,k(k<=m-1). 相当于再给一个offset.
 *      d_i=1,2,3,...,m-1, 称线性探测再散列; 
 *      d_i=1^2,-1^2,2^2,-2^2,...,\pmk^2(k<=m/2), 称二次探测再散列. 只有表长为形如4j+3的素数才能保证未填满必有位;
 *      d_i=伪随机序列, 称伪随机探测再散列
 *  2. 再哈希法: H_i=RH_i(key), i=1,2,...,k. RH_i均是不同的哈希函数. 不易产生聚集, 但增加了计算时间.
 *  3. 链地址法: 同义词记录存在同一个线性链表中. 可以用Chain ChainHash[m]来存储.
 *  4. 建立公共溢出区: 有冲突都填入这个溢出表.
 */
class HashTable {
public:

};
